/**
 * Navin Abichandani
 * Homework #5
 * Recitation 01
 * Recitation TA: Charles Chen 
 * Grading TA: Shilpi Bhattacharyya 
 */
package project5;
import java.io.*;
/**
 * This class creates the TreeNavigator object, which consists of 
 * the TreeNodes.
 */
public class TreeNavigator {
	/**
	 * Root is the first element of the tree.
	 * Cursor is the pointer of the TreeNavigator.
	 */
	private TreeNode root;
	private TreeNode cursor;
	/**
	 * Reads in a text file describing a TreeNavigator.
	 * Preconditions: treeFile is a non-null, non-empty
	 * String that points to a file that exists that is readable and valid.
	 * @param treeFile the input that will give the file name
	 * @return a new TreeNavigator generated by the passed in text file.
	 * @throws IOException if there is no tree
	 */
	public static TreeNavigator buildTree(String treeFile) throws IOException{
		File treeMaker = new File(treeFile);
		BufferedReader in = new BufferedReader(new FileReader(treeMaker));
		TreeNavigator tree = new TreeNavigator();
		String lineReader = in.readLine().trim();
		
		while(lineReader != null){
			String[] splitLine = lineReader.split("\\;");
			String treeLocation = splitLine[0];
			String keywordNames = splitLine[1];
			String leafOrNot = splitLine[2];
			
			String[] keywordsArr = keywordNames.split("\\,");
			
			String[] locationCode = treeLocation.split("\\-");
			
			if(locationCode.length == 1){
				TreeNode node = new TreeNode(keywordsArr);
				tree.setRoot(node);
			}
			
			else{
				tree.cursor = tree.getRoot();
				TreeNode node = new TreeNode(keywordsArr);
				for(int i = 1; i < locationCode.length; i++){
					if(i == locationCode.length - 1){
						if(locationCode[i].equals("0")){
							tree.cursor.setLeft(node);
						}
						else{
							tree.cursor.setRight(node);
						}
					}
					else{
						if(locationCode[i].equals("0")){
							tree.cursor = tree.cursor.getLeft();
						}
						else{
							tree.cursor = tree.cursor.getRight();
						}
					}
				}
			}
			
			tree.setCursor(tree.getRoot());
			try{
			lineReader = in.readLine().trim();
			}
			catch(NullPointerException e){
				break;
			}
		}
		
		tree.cursor = tree.getRoot();
		return tree;
	}	
	/**
	 * Gets root
	 * @return root
	 */
	public TreeNode getRoot() {
		return root;
	}
	/**
	 * Classifies the text with the given tree and returns
	 * the classification as a String.
	 * @param text the sentence that the user inputs.
	 * @return the leaf that the user described.
	 */
	public String classify(String text){
		String[] words = text.split("\\ "); 
		boolean isAKeyword = false;
		
		for(int i = 0; i < cursor.getKeywords().length; i++){
			
			for(int j = 0; j < words.length; j++){
				if(cursor.getKeywords()[i].toLowerCase().equals(words[j])){
					isAKeyword = true;
				}
			}
			if(i == cursor.getKeywords().length - 1){
				if(isAKeyword){
					if(cursor.getRight().isLeaf()){
						return cursor.getRight().getKeywords()[0];
					}
					cursor = cursor.getRight();
					i = -1;	
					isAKeyword = false;
				}
				else{
					if(cursor.getLeft().isLeaf()){
						return cursor.getLeft().getKeywords()[0];
					}
					cursor = cursor.getLeft();
					i = -1;	
				}
			}
		}
		return "";
		}
	/**
	 * Gets the current path of the cursor.
	 * @param text the sentence that the user inputs.
	 * @return a String that gives the step by step direction that
	 * the cursor followed to get to the leaf.
	 */
	public String getPath(String text){
		String[] words = text.split("\\ ");
		String path = "Decision path:";
		boolean isAKeyword = false;
		int ind = 0;
		for(int i = 0; i < cursor.getKeywords().length; i++){
			for(int j = 0; j < words.length; j++){
				if(cursor.getKeywords()[i].toLowerCase().equals(words[j])){
					isAKeyword = true;
					ind = i;
				}
			}
			if(i == cursor.getKeywords().length - 1){
				if(isAKeyword){
					if(cursor.getRight().isLeaf()){
						path += " Is " + cursor.getKeywords()[ind] + ", ";
						path += " Decision = " + cursor.getRight().getKeywords()[0];
						break;
					}
					path += " Is " + cursor.getKeywords()[ind] + ", ";
					cursor = cursor.getRight();
					i = -1;	
					isAKeyword = false;
				}
				else{
					if(cursor.getLeft().isLeaf()){
						path += " Not ";
						for(int k = 0; k < cursor.getKeywords().length; k++){
							path += cursor.getKeywords()[k] + ", ";
						};
						path += " Decision = " + cursor.getLeft().getKeywords()[0];
						break;
					}
					path += " Not ";
					for(int k = 0; k < cursor.getKeywords().length; k++){
						path += cursor.getKeywords()[k] + ", ";
					}
					cursor = cursor.getLeft();
					i = -1;	
				}
			}
		}
		cursor = root;
		return path;
	}
	/**
	 * Resets the cursor to the root node.
	 * Postconditions: Cursor references root node.
	 */
	public void resetCursor(){
		cursor = root;
	}
	/**
	 * Sets left child of cursor.
	 */
	public void cursorLeft(){
		cursor = cursor.getLeft();
	}
	/**
	 * Sets right child of cursor.
	 */
	public void cursorRight(){
		cursor = cursor.getRight();
	}
	/**
	 * Gets cursor
	 * @return the cursor
	 */
	public TreeNode getCursor(){
		return cursor;
	}
	/**
	 * Sets root
	 * @param root the first node in the tree
	 */
	public void setRoot(TreeNode root) {
		this.root = root;
	}
	/**
	 * Sets cursor
	 * @param cursor the pointer of the tree
	 */
	public void setCursor(TreeNode cursor) {
		this.cursor = cursor;
	}
	/**
	 * Edits the keywords of the cursor.
	 * @param text the keywords that will go in the cursor.
	 */
	public void editCursor(String text){
		cursor.setKeywords(text.split("\\,"));
	}
}
